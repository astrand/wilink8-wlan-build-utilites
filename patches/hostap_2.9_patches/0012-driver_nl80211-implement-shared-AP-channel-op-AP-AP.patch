From 85bee1b0e7ef907319e4ded97dc04bf1dce125e4 Mon Sep 17 00:00:00 2001
From: Arik Nemtsov <arik@wizery.com>
Date: Sun, 25 Aug 2013 17:10:26 +0300
Subject: [PATCH 12/47] driver_nl80211: implement shared AP channel op [AP AP]

Dump all AP interfaces using NL80211_CMD_GET_INTERFACE and make sure
the wiphy matches ours.

Signed-off-by: Arik Nemtsov <arik@wizery.com>
---
 src/drivers/driver_nl80211.c | 85 ++++++++++++++++++++++++++++++++++++++++++++
 1 file changed, 85 insertions(+)

diff --git a/src/drivers/driver_nl80211.c b/src/drivers/driver_nl80211.c
index 0a356ee..df00a6e 100644
--- a/src/drivers/driver_nl80211.c
+++ b/src/drivers/driver_nl80211.c
@@ -7865,6 +7865,90 @@ static int nl80211_signal_poll(void *priv, struct wpa_signal_info *si)
 }
 
 
+struct ap_freq_data {
+	int wiphy_idx; /* own idx */
+	struct wpa_channel_info *info;
+};
+
+
+static int ap_freq_info_handler(struct nl_msg *msg, void *arg)
+{
+	struct nlattr *tb[NL80211_ATTR_MAX + 1];
+	struct genlmsghdr *gnlh = nlmsg_data(nlmsg_hdr(msg));
+	struct ap_freq_data *data = arg;
+	enum nl80211_iftype iftype;
+
+	nla_parse(tb, NL80211_ATTR_MAX, genlmsg_attrdata(gnlh, 0),
+		  genlmsg_attrlen(gnlh, 0), NULL);
+
+	if (!tb[NL80211_ATTR_WIPHY] || !tb[NL80211_ATTR_IFTYPE] ||
+	    !tb[NL80211_ATTR_WIPHY_FREQ] ||
+	    !tb[NL80211_ATTR_WIPHY_CHANNEL_TYPE])
+		goto out;
+
+	/* different phy */
+	if (data->wiphy_idx != (int)nla_get_u32(tb[NL80211_ATTR_WIPHY]))
+		goto out;
+
+	/* we only care about APs */
+	iftype = nla_get_u32(tb[NL80211_ATTR_IFTYPE]);
+	if (iftype != NL80211_IFTYPE_AP && iftype != NL80211_IFTYPE_P2P_GO)
+		goto out;
+
+	data->info->frequency = nla_get_u32(tb[NL80211_ATTR_WIPHY_FREQ]);
+
+	switch(nla_get_u32(tb[NL80211_ATTR_WIPHY_CHANNEL_TYPE])) {
+	case NL80211_CHAN_HT40MINUS:
+		data->info->sec_channel_offset = -1;
+		break;
+	case NL80211_CHAN_HT40PLUS:
+		data->info->sec_channel_offset = 1;
+		break;
+	default:
+		data->info->sec_channel_offset = 0;
+		break;
+	}
+
+	wpa_printf(MSG_DEBUG, "nl80211: Got shared AP on freq %d sec chan: %d",
+		   data->info->frequency, data->info->sec_channel_offset);
+
+out:
+	return NL_SKIP;
+}
+
+
+static int wpa_driver_nl80211_shared_ap_freq(void *priv,
+					     struct wpa_channel_info *info)
+{
+	struct i802_bss *bss = priv;
+	struct wpa_driver_nl80211_data *drv = bss->drv;
+	struct nl_msg *msg;
+	struct ap_freq_data data = {
+		.info = info,
+	};
+
+	wpa_printf(MSG_DEBUG, "nl80211: Get shared AP freq for PHY %s",
+		   drv->phyname);
+
+	data.wiphy_idx = nl80211_get_wiphy_index(bss);
+	if (data.wiphy_idx == -1)
+		return -1;
+
+	msg = nlmsg_alloc();
+	if (!msg)
+		return -1;
+
+	nl80211_cmd(drv, msg, NLM_F_DUMP, NL80211_CMD_GET_INTERFACE);
+
+	info->frequency = 0;
+	if (send_and_recv_msgs(drv, msg, ap_freq_info_handler, &data) != 0)
+		return -1;
+
+	wpa_printf(MSG_DEBUG, "nl80211: AP shared freq %d", info->frequency);
+	return info->frequency == 0 ? 0 : 1;
+}
+
+
 static int nl80211_send_frame(void *priv, const u8 *data, size_t data_len,
 			      int encrypt)
 {
@@ -11080,6 +11164,7 @@ const struct wpa_driver_ops wpa_driver_nl80211_ops = {
 	.signal_poll = nl80211_signal_poll,
 	.channel_info = nl80211_channel_info,
 	.send_frame = nl80211_send_frame,
+	.shared_ap_freq = wpa_driver_nl80211_shared_ap_freq,
 	.set_param = nl80211_set_param,
 	.get_radio_name = nl80211_get_radio_name,
 	.add_pmkid = nl80211_add_pmkid,
-- 
1.9.1

