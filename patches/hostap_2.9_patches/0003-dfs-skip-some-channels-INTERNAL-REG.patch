From c5d89589bee03511f3f23c848d1d87b21c3dccae Mon Sep 17 00:00:00 2001
From: Eliad Peller <eliad@wizery.com>
Date: Mon, 24 Feb 2014 10:52:15 +0200
Subject: [PATCH 03/47] dfs: skip some channels [INTERNAL, REG]

Some channels shuldn't be used in the US (even
though they are in the allowed regulatory range).
skip them when choosing a new operating channel.

Signed-off-by: Eliad Peller <eliad@wizery.com>
---
 src/ap/dfs.c | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/src/ap/dfs.c b/src/ap/dfs.c
index ac23c2b..729476e 100644
--- a/src/ap/dfs.c
+++ b/src/ap/dfs.c
@@ -173,6 +173,15 @@ static int dfs_chan_range_available(struct hostapd_hw_modes *mode,
 	return 1;
 }
 
+static int in_array(int *arr, int size, int value)
+{
+	int i;
+
+	for (i = 0; i < size; i++)
+		if (arr[i] == value)
+			return 1;
+	return 0;
+}
 
 static int is_in_chanlist(struct hostapd_iface *iface,
 			  struct hostapd_channel_data *chan)
@@ -198,6 +207,7 @@ static int dfs_find_channel(struct hostapd_iface *iface,
 	struct hostapd_hw_modes *mode;
 	struct hostapd_channel_data *chan;
 	int i, channel_idx = 0, n_chans, n_chans1;
+	int skip_chans[] = { 38, 42, 46 };
 
 	mode = iface->current_mode;
 	n_chans = dfs_get_used_n_chans(iface, &n_chans1);
@@ -206,6 +216,9 @@ static int dfs_find_channel(struct hostapd_iface *iface,
 	for (i = 0; i < mode->num_channels; i++) {
 		chan = &mode->channels[i];
 
+		if (in_array(skip_chans, ARRAY_SIZE(skip_chans), chan->chan))
+			continue;
+
 		/* Skip HT40/VHT incompatible channels */
 		if (iface->conf->ieee80211n &&
 		    iface->conf->secondary_channel &&
-- 
1.9.1

